// Code generated by protoc-gen-go. DO NOT EDIT.
// source: BasicTypes.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type HederaFunctionality int32

const (
	HederaFunctionality_CryptoCreate            HederaFunctionality = 0
	HederaFunctionality_CryptoTransfer          HederaFunctionality = 1
	HederaFunctionality_CryptoUpdate            HederaFunctionality = 2
	HederaFunctionality_CryptoDelete            HederaFunctionality = 3
	HederaFunctionality_CryptoAddClaim          HederaFunctionality = 4
	HederaFunctionality_CryptoDeletClaim        HederaFunctionality = 5
	HederaFunctionality_ContractCall            HederaFunctionality = 6
	HederaFunctionality_ContractCreate          HederaFunctionality = 7
	HederaFunctionality_ContractUpdate          HederaFunctionality = 8
	HederaFunctionality_FileCreate              HederaFunctionality = 9
	HederaFunctionality_FileAppend              HederaFunctionality = 10
	HederaFunctionality_FileUpdate              HederaFunctionality = 11
	HederaFunctionality_FileDelete              HederaFunctionality = 12
	HederaFunctionality_CryptoGetAccountBalance HederaFunctionality = 13
	HederaFunctionality_CryptoGetAccountRecords HederaFunctionality = 14
	HederaFunctionality_CryptoGetInfo           HederaFunctionality = 15
	HederaFunctionality_ContractCallLocal       HederaFunctionality = 16
	HederaFunctionality_ContractGetInfo         HederaFunctionality = 17
	HederaFunctionality_ContractGetBytecode     HederaFunctionality = 18
	HederaFunctionality_GetBySolidityID         HederaFunctionality = 19
	HederaFunctionality_GetByKey                HederaFunctionality = 20
	HederaFunctionality_CryptoGetClaim          HederaFunctionality = 21
	HederaFunctionality_CryptoGetStakers        HederaFunctionality = 22
	HederaFunctionality_FileGetContents         HederaFunctionality = 23
	HederaFunctionality_FileGetInfo             HederaFunctionality = 24
	HederaFunctionality_TransactionGetRecord    HederaFunctionality = 25
)

var HederaFunctionality_name = map[int32]string{
	0:  "CryptoCreate",
	1:  "CryptoTransfer",
	2:  "CryptoUpdate",
	3:  "CryptoDelete",
	4:  "CryptoAddClaim",
	5:  "CryptoDeletClaim",
	6:  "ContractCall",
	7:  "ContractCreate",
	8:  "ContractUpdate",
	9:  "FileCreate",
	10: "FileAppend",
	11: "FileUpdate",
	12: "FileDelete",
	13: "CryptoGetAccountBalance",
	14: "CryptoGetAccountRecords",
	15: "CryptoGetInfo",
	16: "ContractCallLocal",
	17: "ContractGetInfo",
	18: "ContractGetBytecode",
	19: "GetBySolidityID",
	20: "GetByKey",
	21: "CryptoGetClaim",
	22: "CryptoGetStakers",
	23: "FileGetContents",
	24: "FileGetInfo",
	25: "TransactionGetRecord",
}

var HederaFunctionality_value = map[string]int32{
	"CryptoCreate":            0,
	"CryptoTransfer":          1,
	"CryptoUpdate":            2,
	"CryptoDelete":            3,
	"CryptoAddClaim":          4,
	"CryptoDeletClaim":        5,
	"ContractCall":            6,
	"ContractCreate":          7,
	"ContractUpdate":          8,
	"FileCreate":              9,
	"FileAppend":              10,
	"FileUpdate":              11,
	"FileDelete":              12,
	"CryptoGetAccountBalance": 13,
	"CryptoGetAccountRecords": 14,
	"CryptoGetInfo":           15,
	"ContractCallLocal":       16,
	"ContractGetInfo":         17,
	"ContractGetBytecode":     18,
	"GetBySolidityID":         19,
	"GetByKey":                20,
	"CryptoGetClaim":          21,
	"CryptoGetStakers":        22,
	"FileGetContents":         23,
	"FileGetInfo":             24,
	"TransactionGetRecord":    25,
}

func (x HederaFunctionality) String() string {
	return proto.EnumName(HederaFunctionality_name, int32(x))
}

func (HederaFunctionality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{0}
}

// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
//
// Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial.
type ShardID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardID) Reset()         { *m = ShardID{} }
func (m *ShardID) String() string { return proto.CompactTextString(m) }
func (*ShardID) ProtoMessage()    {}
func (*ShardID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{0}
}

func (m *ShardID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ShardID.Unmarshal(m, b)
}
func (m *ShardID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ShardID.Marshal(b, m, deterministic)
}
func (m *ShardID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardID.Merge(m, src)
}
func (m *ShardID) XXX_Size() int {
	return xxx_messageInfo_ShardID.Size(m)
}
func (m *ShardID) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardID.DiscardUnknown(m)
}

var xxx_messageInfo_ShardID proto.InternalMessageInfo

func (m *ShardID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm.
type RealmID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RealmID) Reset()         { *m = RealmID{} }
func (m *RealmID) String() string { return proto.CompactTextString(m) }
func (*RealmID) ProtoMessage()    {}
func (*RealmID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{1}
}

func (m *RealmID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RealmID.Unmarshal(m, b)
}
func (m *RealmID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RealmID.Marshal(b, m, deterministic)
}
func (m *RealmID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RealmID.Merge(m, src)
}
func (m *RealmID) XXX_Size() int {
	return xxx_messageInfo_RealmID.Size(m)
}
func (m *RealmID) XXX_DiscardUnknown() {
	xxx_messageInfo_RealmID.DiscardUnknown(m)
}

var xxx_messageInfo_RealmID proto.InternalMessageInfo

func (m *RealmID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *RealmID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

// The ID for an a cryptocurrency account
type AccountID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	AccountNum           int64    `protobuf:"varint,3,opt,name=accountNum,proto3" json:"accountNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccountID) Reset()         { *m = AccountID{} }
func (m *AccountID) String() string { return proto.CompactTextString(m) }
func (*AccountID) ProtoMessage()    {}
func (*AccountID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{2}
}

func (m *AccountID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccountID.Unmarshal(m, b)
}
func (m *AccountID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccountID.Marshal(b, m, deterministic)
}
func (m *AccountID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountID.Merge(m, src)
}
func (m *AccountID) XXX_Size() int {
	return xxx_messageInfo_AccountID.Size(m)
}
func (m *AccountID) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountID.DiscardUnknown(m)
}

var xxx_messageInfo_AccountID proto.InternalMessageInfo

func (m *AccountID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *AccountID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *AccountID) GetAccountNum() int64 {
	if m != nil {
		return m.AccountNum
	}
	return 0
}

// The ID for a file
type FileID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	FileNum              int64    `protobuf:"varint,3,opt,name=fileNum,proto3" json:"fileNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileID) Reset()         { *m = FileID{} }
func (m *FileID) String() string { return proto.CompactTextString(m) }
func (*FileID) ProtoMessage()    {}
func (*FileID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{3}
}

func (m *FileID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileID.Unmarshal(m, b)
}
func (m *FileID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileID.Marshal(b, m, deterministic)
}
func (m *FileID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileID.Merge(m, src)
}
func (m *FileID) XXX_Size() int {
	return xxx_messageInfo_FileID.Size(m)
}
func (m *FileID) XXX_DiscardUnknown() {
	xxx_messageInfo_FileID.DiscardUnknown(m)
}

var xxx_messageInfo_FileID proto.InternalMessageInfo

func (m *FileID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *FileID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *FileID) GetFileNum() int64 {
	if m != nil {
		return m.FileNum
	}
	return 0
}

// The ID for a smart contract instance
type ContractID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	ContractNum          int64    `protobuf:"varint,3,opt,name=contractNum,proto3" json:"contractNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContractID) Reset()         { *m = ContractID{} }
func (m *ContractID) String() string { return proto.CompactTextString(m) }
func (*ContractID) ProtoMessage()    {}
func (*ContractID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{4}
}

func (m *ContractID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContractID.Unmarshal(m, b)
}
func (m *ContractID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContractID.Marshal(b, m, deterministic)
}
func (m *ContractID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractID.Merge(m, src)
}
func (m *ContractID) XXX_Size() int {
	return xxx_messageInfo_ContractID.Size(m)
}
func (m *ContractID) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractID.DiscardUnknown(m)
}

var xxx_messageInfo_ContractID proto.InternalMessageInfo

func (m *ContractID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *ContractID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *ContractID) GetContractNum() int64 {
	if m != nil {
		return m.ContractNum
	}
	return 0
}

// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes.
type TransactionID struct {
	AccountID             *AccountID `protobuf:"bytes,2,opt,name=accountID,proto3" json:"accountID,omitempty"`
	TransactionValidStart *Timestamp `protobuf:"bytes,1,opt,name=transactionValidStart,proto3" json:"transactionValidStart,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}   `json:"-"`
	XXX_unrecognized      []byte     `json:"-"`
	XXX_sizecache         int32      `json:"-"`
}

func (m *TransactionID) Reset()         { *m = TransactionID{} }
func (m *TransactionID) String() string { return proto.CompactTextString(m) }
func (*TransactionID) ProtoMessage()    {}
func (*TransactionID) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{5}
}

func (m *TransactionID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionID.Unmarshal(m, b)
}
func (m *TransactionID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionID.Marshal(b, m, deterministic)
}
func (m *TransactionID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionID.Merge(m, src)
}
func (m *TransactionID) XXX_Size() int {
	return xxx_messageInfo_TransactionID.Size(m)
}
func (m *TransactionID) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionID.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionID proto.InternalMessageInfo

func (m *TransactionID) GetAccountID() *AccountID {
	if m != nil {
		return m.AccountID
	}
	return nil
}

func (m *TransactionID) GetTransactionValidStart() *Timestamp {
	if m != nil {
		return m.TransactionValidStart
	}
	return nil
}

// A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
//
// A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
//
// A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
//
// A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.
//
// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. The current API only allows the nesting to a depth of 3 levels, such as the key being a list of threshold keys, each of which contains a list of primitive keys (e.g., ed25519). In the future, this requirement may be relaxed, to allow deeper nesting.
type Key struct {
	// Types that are valid to be assigned to Key:
	//	*Key_ContractID
	//	*Key_Ed25519
	//	*Key_RSA_3072
	//	*Key_ECDSA_384
	//	*Key_ThresholdKey
	//	*Key_KeyList
	Key                  isKey_Key `protobuf_oneof:"key"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{6}
}

func (m *Key) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key.Unmarshal(m, b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key.Marshal(b, m, deterministic)
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return xxx_messageInfo_Key.Size(m)
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

type isKey_Key interface {
	isKey_Key()
}

type Key_ContractID struct {
	ContractID *ContractID `protobuf:"bytes,1,opt,name=contractID,proto3,oneof"`
}

type Key_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,2,opt,name=ed25519,proto3,oneof"`
}

type Key_RSA_3072 struct {
	RSA_3072 []byte `protobuf:"bytes,3,opt,name=RSA_3072,json=RSA3072,proto3,oneof"`
}

type Key_ECDSA_384 struct {
	ECDSA_384 []byte `protobuf:"bytes,4,opt,name=ECDSA_384,json=ECDSA384,proto3,oneof"`
}

type Key_ThresholdKey struct {
	ThresholdKey *ThresholdKey `protobuf:"bytes,5,opt,name=thresholdKey,proto3,oneof"`
}

type Key_KeyList struct {
	KeyList *KeyList `protobuf:"bytes,6,opt,name=keyList,proto3,oneof"`
}

func (*Key_ContractID) isKey_Key() {}

func (*Key_Ed25519) isKey_Key() {}

func (*Key_RSA_3072) isKey_Key() {}

func (*Key_ECDSA_384) isKey_Key() {}

func (*Key_ThresholdKey) isKey_Key() {}

func (*Key_KeyList) isKey_Key() {}

func (m *Key) GetKey() isKey_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Key) GetContractID() *ContractID {
	if x, ok := m.GetKey().(*Key_ContractID); ok {
		return x.ContractID
	}
	return nil
}

func (m *Key) GetEd25519() []byte {
	if x, ok := m.GetKey().(*Key_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *Key) GetRSA_3072() []byte {
	if x, ok := m.GetKey().(*Key_RSA_3072); ok {
		return x.RSA_3072
	}
	return nil
}

func (m *Key) GetECDSA_384() []byte {
	if x, ok := m.GetKey().(*Key_ECDSA_384); ok {
		return x.ECDSA_384
	}
	return nil
}

func (m *Key) GetThresholdKey() *ThresholdKey {
	if x, ok := m.GetKey().(*Key_ThresholdKey); ok {
		return x.ThresholdKey
	}
	return nil
}

func (m *Key) GetKeyList() *KeyList {
	if x, ok := m.GetKey().(*Key_KeyList); ok {
		return x.KeyList
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Key) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Key_OneofMarshaler, _Key_OneofUnmarshaler, _Key_OneofSizer, []interface{}{
		(*Key_ContractID)(nil),
		(*Key_Ed25519)(nil),
		(*Key_RSA_3072)(nil),
		(*Key_ECDSA_384)(nil),
		(*Key_ThresholdKey)(nil),
		(*Key_KeyList)(nil),
	}
}

func _Key_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Key)
	// key
	switch x := m.Key.(type) {
	case *Key_ContractID:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContractID); err != nil {
			return err
		}
	case *Key_Ed25519:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Ed25519)
	case *Key_RSA_3072:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.RSA_3072)
	case *Key_ECDSA_384:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ECDSA_384)
	case *Key_ThresholdKey:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ThresholdKey); err != nil {
			return err
		}
	case *Key_KeyList:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.KeyList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Key.Key has unexpected type %T", x)
	}
	return nil
}

func _Key_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Key)
	switch tag {
	case 1: // key.contractID
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContractID)
		err := b.DecodeMessage(msg)
		m.Key = &Key_ContractID{msg}
		return true, err
	case 2: // key.ed25519
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Key = &Key_Ed25519{x}
		return true, err
	case 3: // key.RSA_3072
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Key = &Key_RSA_3072{x}
		return true, err
	case 4: // key.ECDSA_384
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Key = &Key_ECDSA_384{x}
		return true, err
	case 5: // key.thresholdKey
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ThresholdKey)
		err := b.DecodeMessage(msg)
		m.Key = &Key_ThresholdKey{msg}
		return true, err
	case 6: // key.keyList
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KeyList)
		err := b.DecodeMessage(msg)
		m.Key = &Key_KeyList{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Key_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Key)
	// key
	switch x := m.Key.(type) {
	case *Key_ContractID:
		s := proto.Size(x.ContractID)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Key_Ed25519:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Ed25519)))
		n += len(x.Ed25519)
	case *Key_RSA_3072:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.RSA_3072)))
		n += len(x.RSA_3072)
	case *Key_ECDSA_384:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.ECDSA_384)))
		n += len(x.ECDSA_384)
	case *Key_ThresholdKey:
		s := proto.Size(x.ThresholdKey)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Key_KeyList:
		s := proto.Size(x.KeyList)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here.
type ThresholdKey struct {
	Threshold            uint32   `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Keys                 *KeyList `protobuf:"bytes,2,opt,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThresholdKey) Reset()         { *m = ThresholdKey{} }
func (m *ThresholdKey) String() string { return proto.CompactTextString(m) }
func (*ThresholdKey) ProtoMessage()    {}
func (*ThresholdKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{7}
}

func (m *ThresholdKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ThresholdKey.Unmarshal(m, b)
}
func (m *ThresholdKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ThresholdKey.Marshal(b, m, deterministic)
}
func (m *ThresholdKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdKey.Merge(m, src)
}
func (m *ThresholdKey) XXX_Size() int {
	return xxx_messageInfo_ThresholdKey.Size(m)
}
func (m *ThresholdKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdKey.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdKey proto.InternalMessageInfo

func (m *ThresholdKey) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *ThresholdKey) GetKeys() *KeyList {
	if m != nil {
		return m.Keys
	}
	return nil
}

// A list of keys
type KeyList struct {
	Keys                 []*Key   `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyList) Reset()         { *m = KeyList{} }
func (m *KeyList) String() string { return proto.CompactTextString(m) }
func (*KeyList) ProtoMessage()    {}
func (*KeyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{8}
}

func (m *KeyList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyList.Unmarshal(m, b)
}
func (m *KeyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyList.Marshal(b, m, deterministic)
}
func (m *KeyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyList.Merge(m, src)
}
func (m *KeyList) XXX_Size() int {
	return xxx_messageInfo_KeyList.Size(m)
}
func (m *KeyList) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyList.DiscardUnknown(m)
}

var xxx_messageInfo_KeyList proto.InternalMessageInfo

func (m *KeyList) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
//
// The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
type Signature struct {
	// Types that are valid to be assigned to Signature:
	//	*Signature_Contract
	//	*Signature_Ed25519
	//	*Signature_RSA_3072
	//	*Signature_ECDSA_384
	//	*Signature_ThresholdSignature
	//	*Signature_SignatureList
	Signature            isSignature_Signature `protobuf_oneof:"signature"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{9}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

type isSignature_Signature interface {
	isSignature_Signature()
}

type Signature_Contract struct {
	Contract []byte `protobuf:"bytes,1,opt,name=contract,proto3,oneof"`
}

type Signature_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,2,opt,name=ed25519,proto3,oneof"`
}

type Signature_RSA_3072 struct {
	RSA_3072 []byte `protobuf:"bytes,3,opt,name=RSA_3072,json=RSA3072,proto3,oneof"`
}

type Signature_ECDSA_384 struct {
	ECDSA_384 []byte `protobuf:"bytes,4,opt,name=ECDSA_384,json=ECDSA384,proto3,oneof"`
}

type Signature_ThresholdSignature struct {
	ThresholdSignature *ThresholdSignature `protobuf:"bytes,5,opt,name=thresholdSignature,proto3,oneof"`
}

type Signature_SignatureList struct {
	SignatureList *SignatureList `protobuf:"bytes,6,opt,name=signatureList,proto3,oneof"`
}

func (*Signature_Contract) isSignature_Signature() {}

func (*Signature_Ed25519) isSignature_Signature() {}

func (*Signature_RSA_3072) isSignature_Signature() {}

func (*Signature_ECDSA_384) isSignature_Signature() {}

func (*Signature_ThresholdSignature) isSignature_Signature() {}

func (*Signature_SignatureList) isSignature_Signature() {}

func (m *Signature) GetSignature() isSignature_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signature) GetContract() []byte {
	if x, ok := m.GetSignature().(*Signature_Contract); ok {
		return x.Contract
	}
	return nil
}

func (m *Signature) GetEd25519() []byte {
	if x, ok := m.GetSignature().(*Signature_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *Signature) GetRSA_3072() []byte {
	if x, ok := m.GetSignature().(*Signature_RSA_3072); ok {
		return x.RSA_3072
	}
	return nil
}

func (m *Signature) GetECDSA_384() []byte {
	if x, ok := m.GetSignature().(*Signature_ECDSA_384); ok {
		return x.ECDSA_384
	}
	return nil
}

func (m *Signature) GetThresholdSignature() *ThresholdSignature {
	if x, ok := m.GetSignature().(*Signature_ThresholdSignature); ok {
		return x.ThresholdSignature
	}
	return nil
}

func (m *Signature) GetSignatureList() *SignatureList {
	if x, ok := m.GetSignature().(*Signature_SignatureList); ok {
		return x.SignatureList
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Signature) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Signature_OneofMarshaler, _Signature_OneofUnmarshaler, _Signature_OneofSizer, []interface{}{
		(*Signature_Contract)(nil),
		(*Signature_Ed25519)(nil),
		(*Signature_RSA_3072)(nil),
		(*Signature_ECDSA_384)(nil),
		(*Signature_ThresholdSignature)(nil),
		(*Signature_SignatureList)(nil),
	}
}

func _Signature_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Signature)
	// signature
	switch x := m.Signature.(type) {
	case *Signature_Contract:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Contract)
	case *Signature_Ed25519:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Ed25519)
	case *Signature_RSA_3072:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.RSA_3072)
	case *Signature_ECDSA_384:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ECDSA_384)
	case *Signature_ThresholdSignature:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ThresholdSignature); err != nil {
			return err
		}
	case *Signature_SignatureList:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SignatureList); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Signature.Signature has unexpected type %T", x)
	}
	return nil
}

func _Signature_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Signature)
	switch tag {
	case 1: // signature.contract
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Signature = &Signature_Contract{x}
		return true, err
	case 2: // signature.ed25519
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Signature = &Signature_Ed25519{x}
		return true, err
	case 3: // signature.RSA_3072
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Signature = &Signature_RSA_3072{x}
		return true, err
	case 4: // signature.ECDSA_384
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Signature = &Signature_ECDSA_384{x}
		return true, err
	case 5: // signature.thresholdSignature
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ThresholdSignature)
		err := b.DecodeMessage(msg)
		m.Signature = &Signature_ThresholdSignature{msg}
		return true, err
	case 6: // signature.signatureList
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SignatureList)
		err := b.DecodeMessage(msg)
		m.Signature = &Signature_SignatureList{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Signature_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Signature)
	// signature
	switch x := m.Signature.(type) {
	case *Signature_Contract:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Contract)))
		n += len(x.Contract)
	case *Signature_Ed25519:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Ed25519)))
		n += len(x.Ed25519)
	case *Signature_RSA_3072:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.RSA_3072)))
		n += len(x.RSA_3072)
	case *Signature_ECDSA_384:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.ECDSA_384)))
		n += len(x.ECDSA_384)
	case *Signature_ThresholdSignature:
		s := proto.Size(x.ThresholdSignature)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Signature_SignatureList:
		s := proto.Size(x.SignatureList)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null.
type ThresholdSignature struct {
	Sigs                 *SignatureList `protobuf:"bytes,2,opt,name=sigs,proto3" json:"sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ThresholdSignature) Reset()         { *m = ThresholdSignature{} }
func (m *ThresholdSignature) String() string { return proto.CompactTextString(m) }
func (*ThresholdSignature) ProtoMessage()    {}
func (*ThresholdSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{10}
}

func (m *ThresholdSignature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ThresholdSignature.Unmarshal(m, b)
}
func (m *ThresholdSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ThresholdSignature.Marshal(b, m, deterministic)
}
func (m *ThresholdSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdSignature.Merge(m, src)
}
func (m *ThresholdSignature) XXX_Size() int {
	return xxx_messageInfo_ThresholdSignature.Size(m)
}
func (m *ThresholdSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdSignature proto.InternalMessageInfo

func (m *ThresholdSignature) GetSigs() *SignatureList {
	if m != nil {
		return m.Sigs
	}
	return nil
}

// The signatures corresponding to a KeyList of the same length
type SignatureList struct {
	Sigs                 []*Signature `protobuf:"bytes,2,rep,name=sigs,proto3" json:"sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SignatureList) Reset()         { *m = SignatureList{} }
func (m *SignatureList) String() string { return proto.CompactTextString(m) }
func (*SignatureList) ProtoMessage()    {}
func (*SignatureList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{11}
}

func (m *SignatureList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureList.Unmarshal(m, b)
}
func (m *SignatureList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureList.Marshal(b, m, deterministic)
}
func (m *SignatureList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureList.Merge(m, src)
}
func (m *SignatureList) XXX_Size() int {
	return xxx_messageInfo_SignatureList.Size(m)
}
func (m *SignatureList) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureList.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureList proto.InternalMessageInfo

func (m *SignatureList) GetSigs() []*Signature {
	if m != nil {
		return m.Sigs
	}
	return nil
}

type FeeComponents struct {
	Min                  int64    `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	Max                  int64    `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	Constant             int64    `protobuf:"varint,3,opt,name=constant,proto3" json:"constant,omitempty"`
	Bpt                  int64    `protobuf:"varint,4,opt,name=bpt,proto3" json:"bpt,omitempty"`
	Vpt                  int64    `protobuf:"varint,5,opt,name=vpt,proto3" json:"vpt,omitempty"`
	Rbs                  int64    `protobuf:"varint,6,opt,name=rbs,proto3" json:"rbs,omitempty"`
	Sbs                  int64    `protobuf:"varint,7,opt,name=sbs,proto3" json:"sbs,omitempty"`
	Gas                  int64    `protobuf:"varint,8,opt,name=gas,proto3" json:"gas,omitempty"`
	Tv                   int64    `protobuf:"varint,9,opt,name=tv,proto3" json:"tv,omitempty"`
	Bpr                  int64    `protobuf:"varint,10,opt,name=bpr,proto3" json:"bpr,omitempty"`
	Sbpr                 int64    `protobuf:"varint,11,opt,name=sbpr,proto3" json:"sbpr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeeComponents) Reset()         { *m = FeeComponents{} }
func (m *FeeComponents) String() string { return proto.CompactTextString(m) }
func (*FeeComponents) ProtoMessage()    {}
func (*FeeComponents) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{12}
}

func (m *FeeComponents) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeeComponents.Unmarshal(m, b)
}
func (m *FeeComponents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeeComponents.Marshal(b, m, deterministic)
}
func (m *FeeComponents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeComponents.Merge(m, src)
}
func (m *FeeComponents) XXX_Size() int {
	return xxx_messageInfo_FeeComponents.Size(m)
}
func (m *FeeComponents) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeComponents.DiscardUnknown(m)
}

var xxx_messageInfo_FeeComponents proto.InternalMessageInfo

func (m *FeeComponents) GetMin() int64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *FeeComponents) GetMax() int64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *FeeComponents) GetConstant() int64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

func (m *FeeComponents) GetBpt() int64 {
	if m != nil {
		return m.Bpt
	}
	return 0
}

func (m *FeeComponents) GetVpt() int64 {
	if m != nil {
		return m.Vpt
	}
	return 0
}

func (m *FeeComponents) GetRbs() int64 {
	if m != nil {
		return m.Rbs
	}
	return 0
}

func (m *FeeComponents) GetSbs() int64 {
	if m != nil {
		return m.Sbs
	}
	return 0
}

func (m *FeeComponents) GetGas() int64 {
	if m != nil {
		return m.Gas
	}
	return 0
}

func (m *FeeComponents) GetTv() int64 {
	if m != nil {
		return m.Tv
	}
	return 0
}

func (m *FeeComponents) GetBpr() int64 {
	if m != nil {
		return m.Bpr
	}
	return 0
}

func (m *FeeComponents) GetSbpr() int64 {
	if m != nil {
		return m.Sbpr
	}
	return 0
}

type TransactionFeeSchedule struct {
	HederaFunctionality  HederaFunctionality `protobuf:"varint,1,opt,name=hederaFunctionality,proto3,enum=proto.HederaFunctionality" json:"hederaFunctionality,omitempty"`
	FeeData              *FeeData            `protobuf:"bytes,2,opt,name=feeData,proto3" json:"feeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TransactionFeeSchedule) Reset()         { *m = TransactionFeeSchedule{} }
func (m *TransactionFeeSchedule) String() string { return proto.CompactTextString(m) }
func (*TransactionFeeSchedule) ProtoMessage()    {}
func (*TransactionFeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{13}
}

func (m *TransactionFeeSchedule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionFeeSchedule.Unmarshal(m, b)
}
func (m *TransactionFeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionFeeSchedule.Marshal(b, m, deterministic)
}
func (m *TransactionFeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionFeeSchedule.Merge(m, src)
}
func (m *TransactionFeeSchedule) XXX_Size() int {
	return xxx_messageInfo_TransactionFeeSchedule.Size(m)
}
func (m *TransactionFeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionFeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionFeeSchedule proto.InternalMessageInfo

func (m *TransactionFeeSchedule) GetHederaFunctionality() HederaFunctionality {
	if m != nil {
		return m.HederaFunctionality
	}
	return HederaFunctionality_CryptoCreate
}

func (m *TransactionFeeSchedule) GetFeeData() *FeeData {
	if m != nil {
		return m.FeeData
	}
	return nil
}

type FeeData struct {
	Nodedata             *FeeComponents `protobuf:"bytes,1,opt,name=nodedata,proto3" json:"nodedata,omitempty"`
	Networkdata          *FeeComponents `protobuf:"bytes,2,opt,name=networkdata,proto3" json:"networkdata,omitempty"`
	Servicedata          *FeeComponents `protobuf:"bytes,3,opt,name=servicedata,proto3" json:"servicedata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FeeData) Reset()         { *m = FeeData{} }
func (m *FeeData) String() string { return proto.CompactTextString(m) }
func (*FeeData) ProtoMessage()    {}
func (*FeeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{14}
}

func (m *FeeData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeeData.Unmarshal(m, b)
}
func (m *FeeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeeData.Marshal(b, m, deterministic)
}
func (m *FeeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeData.Merge(m, src)
}
func (m *FeeData) XXX_Size() int {
	return xxx_messageInfo_FeeData.Size(m)
}
func (m *FeeData) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeData.DiscardUnknown(m)
}

var xxx_messageInfo_FeeData proto.InternalMessageInfo

func (m *FeeData) GetNodedata() *FeeComponents {
	if m != nil {
		return m.Nodedata
	}
	return nil
}

func (m *FeeData) GetNetworkdata() *FeeComponents {
	if m != nil {
		return m.Networkdata
	}
	return nil
}

func (m *FeeData) GetServicedata() *FeeComponents {
	if m != nil {
		return m.Servicedata
	}
	return nil
}

type FeeSchedule struct {
	TransactionFeeSchedule      []*TransactionFeeSchedule `protobuf:"bytes,1,rep,name=transactionFeeSchedule,proto3" json:"transactionFeeSchedule,omitempty"`
	FeeScheduleValidityDuration *Duration                 `protobuf:"bytes,2,opt,name=feeScheduleValidityDuration,proto3" json:"feeScheduleValidityDuration,omitempty"`
	XXX_NoUnkeyedLiteral        struct{}                  `json:"-"`
	XXX_unrecognized            []byte                    `json:"-"`
	XXX_sizecache               int32                     `json:"-"`
}

func (m *FeeSchedule) Reset()         { *m = FeeSchedule{} }
func (m *FeeSchedule) String() string { return proto.CompactTextString(m) }
func (*FeeSchedule) ProtoMessage()    {}
func (*FeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{15}
}

func (m *FeeSchedule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeeSchedule.Unmarshal(m, b)
}
func (m *FeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeeSchedule.Marshal(b, m, deterministic)
}
func (m *FeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeSchedule.Merge(m, src)
}
func (m *FeeSchedule) XXX_Size() int {
	return xxx_messageInfo_FeeSchedule.Size(m)
}
func (m *FeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_FeeSchedule proto.InternalMessageInfo

func (m *FeeSchedule) GetTransactionFeeSchedule() []*TransactionFeeSchedule {
	if m != nil {
		return m.TransactionFeeSchedule
	}
	return nil
}

func (m *FeeSchedule) GetFeeScheduleValidityDuration() *Duration {
	if m != nil {
		return m.FeeScheduleValidityDuration
	}
	return nil
}

type NodeAddress struct {
	IpAddress            []byte   `protobuf:"bytes,1,opt,name=ipAddress,proto3" json:"ipAddress,omitempty"`
	Portno               int32    `protobuf:"varint,2,opt,name=portno,proto3" json:"portno,omitempty"`
	Memo                 []byte   `protobuf:"bytes,3,opt,name=memo,proto3" json:"memo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeAddress) Reset()         { *m = NodeAddress{} }
func (m *NodeAddress) String() string { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()    {}
func (*NodeAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{16}
}

func (m *NodeAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeAddress.Unmarshal(m, b)
}
func (m *NodeAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeAddress.Marshal(b, m, deterministic)
}
func (m *NodeAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddress.Merge(m, src)
}
func (m *NodeAddress) XXX_Size() int {
	return xxx_messageInfo_NodeAddress.Size(m)
}
func (m *NodeAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddress.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddress proto.InternalMessageInfo

func (m *NodeAddress) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NodeAddress) GetPortno() int32 {
	if m != nil {
		return m.Portno
	}
	return 0
}

func (m *NodeAddress) GetMemo() []byte {
	if m != nil {
		return m.Memo
	}
	return nil
}

type NodeAddressBook struct {
	NodeAddress          []*NodeAddress `protobuf:"bytes,1,rep,name=nodeAddress,proto3" json:"nodeAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NodeAddressBook) Reset()         { *m = NodeAddressBook{} }
func (m *NodeAddressBook) String() string { return proto.CompactTextString(m) }
func (*NodeAddressBook) ProtoMessage()    {}
func (*NodeAddressBook) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7917cbf7afa9e9a, []int{17}
}

func (m *NodeAddressBook) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeAddressBook.Unmarshal(m, b)
}
func (m *NodeAddressBook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeAddressBook.Marshal(b, m, deterministic)
}
func (m *NodeAddressBook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddressBook.Merge(m, src)
}
func (m *NodeAddressBook) XXX_Size() int {
	return xxx_messageInfo_NodeAddressBook.Size(m)
}
func (m *NodeAddressBook) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddressBook.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddressBook proto.InternalMessageInfo

func (m *NodeAddressBook) GetNodeAddress() []*NodeAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.HederaFunctionality", HederaFunctionality_name, HederaFunctionality_value)
	proto.RegisterType((*ShardID)(nil), "proto.ShardID")
	proto.RegisterType((*RealmID)(nil), "proto.RealmID")
	proto.RegisterType((*AccountID)(nil), "proto.AccountID")
	proto.RegisterType((*FileID)(nil), "proto.FileID")
	proto.RegisterType((*ContractID)(nil), "proto.ContractID")
	proto.RegisterType((*TransactionID)(nil), "proto.TransactionID")
	proto.RegisterType((*Key)(nil), "proto.Key")
	proto.RegisterType((*ThresholdKey)(nil), "proto.ThresholdKey")
	proto.RegisterType((*KeyList)(nil), "proto.KeyList")
	proto.RegisterType((*Signature)(nil), "proto.Signature")
	proto.RegisterType((*ThresholdSignature)(nil), "proto.ThresholdSignature")
	proto.RegisterType((*SignatureList)(nil), "proto.SignatureList")
	proto.RegisterType((*FeeComponents)(nil), "proto.FeeComponents")
	proto.RegisterType((*TransactionFeeSchedule)(nil), "proto.TransactionFeeSchedule")
	proto.RegisterType((*FeeData)(nil), "proto.FeeData")
	proto.RegisterType((*FeeSchedule)(nil), "proto.FeeSchedule")
	proto.RegisterType((*NodeAddress)(nil), "proto.NodeAddress")
	proto.RegisterType((*NodeAddressBook)(nil), "proto.NodeAddressBook")
}

func init() { proto.RegisterFile("BasicTypes.proto", fileDescriptor_a7917cbf7afa9e9a) }

var fileDescriptor_a7917cbf7afa9e9a = []byte{
	// 1148 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcb, 0x6e, 0x23, 0x45,
	0x14, 0xb5, 0xdd, 0x4e, 0x6c, 0x5f, 0xbf, 0x3a, 0xe5, 0x4c, 0xc6, 0x93, 0xcc, 0x8c, 0xa2, 0x16,
	0xa0, 0x30, 0x8b, 0x68, 0xc8, 0x03, 0x66, 0x24, 0x84, 0xe4, 0x07, 0x8e, 0xa3, 0x44, 0xa3, 0xa1,
	0x9c, 0x01, 0x89, 0x0d, 0xaa, 0x74, 0x97, 0xe3, 0xc6, 0xed, 0xae, 0x56, 0x55, 0x39, 0xe0, 0x1d,
	0x3b, 0xb6, 0x6c, 0xd9, 0xb2, 0xe5, 0x03, 0xf8, 0x1c, 0x7e, 0x05, 0x55, 0x75, 0xf5, 0x23, 0x19,
	0x93, 0x05, 0x23, 0x56, 0xa9, 0x7b, 0xee, 0xb9, 0xaf, 0x53, 0x5d, 0x37, 0x06, 0xbb, 0x4f, 0x84,
	0xef, 0x5e, 0xad, 0x22, 0x2a, 0x0e, 0x23, 0xce, 0x24, 0x43, 0x1b, 0xfa, 0xcf, 0x6e, 0xfb, 0xca,
	0x5f, 0x50, 0x21, 0xc9, 0x22, 0x8a, 0xf1, 0xdd, 0xd6, 0x70, 0xc9, 0x89, 0xf4, 0x59, 0x18, 0xdb,
	0xce, 0xc7, 0x50, 0x99, 0xcc, 0x08, 0xf7, 0xce, 0x87, 0x68, 0x17, 0xaa, 0x42, 0x1d, 0xdf, 0x2c,
	0x17, 0xdd, 0xe2, 0x7e, 0xf1, 0xc0, 0xc2, 0xa9, 0xed, 0xf4, 0xa0, 0x82, 0x29, 0x09, 0x16, 0x0f,
	0xd3, 0x94, 0x8f, 0x2b, 0x9a, 0xf2, 0x95, 0x62, 0x5f, 0x62, 0x3b, 0x2e, 0xd4, 0x7a, 0xae, 0xcb,
	0x96, 0xa1, 0xfc, 0xef, 0x49, 0xd0, 0x73, 0x00, 0x12, 0x27, 0x51, 0x5e, 0x4b, 0x7b, 0x73, 0x88,
	0xf3, 0x3d, 0x6c, 0x8e, 0xfc, 0x80, 0x7e, 0x40, 0x85, 0x2e, 0x54, 0xa6, 0x7e, 0x40, 0xb3, 0xf4,
	0x89, 0xe9, 0x4c, 0x01, 0x06, 0x2c, 0x94, 0x9c, 0xb8, 0x1f, 0x32, 0xc1, 0x3e, 0xd4, 0x5d, 0x93,
	0x25, 0xab, 0x91, 0x87, 0x9c, 0x5f, 0x8b, 0xd0, 0xbc, 0xe2, 0x24, 0x14, 0xc4, 0x55, 0x17, 0x75,
	0x3e, 0x44, 0x87, 0x50, 0x23, 0x89, 0x74, 0x3a, 0x61, 0xfd, 0xc8, 0x8e, 0xef, 0xef, 0x30, 0x95,
	0x14, 0x67, 0x14, 0x34, 0x82, 0x47, 0x32, 0x4b, 0xf0, 0x2d, 0x09, 0x7c, 0x6f, 0x22, 0x09, 0x97,
	0xba, 0xd1, 0x2c, 0x36, 0xfd, 0x36, 0xf0, 0x7a, 0xba, 0xf3, 0x4b, 0x09, 0xac, 0x0b, 0xba, 0x42,
	0xc7, 0x00, 0x6e, 0x3a, 0xb9, 0x49, 0xb2, 0x65, 0x92, 0x64, 0x92, 0x8c, 0x0b, 0x38, 0x47, 0x43,
	0xbb, 0x50, 0xa1, 0xde, 0xd1, 0xe9, 0xe9, 0x67, 0xaf, 0x75, 0xcb, 0x8d, 0x71, 0x01, 0x27, 0x00,
	0xda, 0x83, 0x2a, 0x9e, 0xf4, 0x7e, 0x38, 0x7e, 0xf9, 0xc5, 0x91, 0x56, 0x40, 0x3b, 0xf1, 0xa4,
	0xa7, 0x00, 0xf4, 0x0c, 0x6a, 0x5f, 0x0f, 0x86, 0xca, 0xfd, 0xea, 0xa4, 0x5b, 0x36, 0xde, 0xaa,
	0x86, 0x8e, 0x5f, 0x9d, 0xa0, 0xd7, 0xd0, 0x90, 0x33, 0x4e, 0xc5, 0x8c, 0x05, 0xde, 0x05, 0x5d,
	0x75, 0x37, 0x74, 0x3b, 0x9d, 0x64, 0xa6, 0x9c, 0x6b, 0x5c, 0xc0, 0x77, 0xa8, 0xe8, 0x05, 0x54,
	0xe6, 0x74, 0x75, 0xe9, 0x0b, 0xd9, 0xdd, 0xd4, 0x51, 0x2d, 0x13, 0x75, 0x11, 0xa3, 0xaa, 0x0b,
	0x43, 0xe8, 0x6f, 0x80, 0x35, 0xa7, 0x2b, 0xe7, 0x2d, 0x34, 0xf2, 0x29, 0xd1, 0x53, 0xa8, 0xa5,
	0x29, 0xb5, 0x12, 0x4d, 0x9c, 0x01, 0xc8, 0x81, 0xf2, 0x9c, 0xae, 0x84, 0xb9, 0xa3, 0x7b, 0xd9,
	0xb1, 0xf6, 0x39, 0x9f, 0x42, 0xc5, 0x00, 0xe8, 0xb9, 0xa1, 0x17, 0xf7, 0xad, 0x83, 0xfa, 0x11,
	0x64, 0x74, 0x43, 0xfd, 0xbd, 0x04, 0xb5, 0x89, 0x7f, 0x13, 0x12, 0xb9, 0xe4, 0x14, 0x3d, 0x85,
	0x6a, 0x22, 0xaf, 0xae, 0xac, 0x65, 0x49, 0x90, 0xff, 0x4d, 0xee, 0x0b, 0x40, 0xe9, 0x7c, 0x69,
	0x2f, 0x46, 0xf4, 0x27, 0xf7, 0x45, 0x4f, 0x09, 0xe3, 0x02, 0x5e, 0x13, 0x86, 0xbe, 0x84, 0xa6,
	0x48, 0x8c, 0xdc, 0x35, 0x6c, 0x9b, 0x3c, 0x93, 0xbc, 0x6f, 0x5c, 0xc0, 0x77, 0xc9, 0xfd, 0x3a,
	0xd4, 0x52, 0xc0, 0xf9, 0x0a, 0xd0, 0xfb, 0x65, 0xd1, 0x01, 0x94, 0x85, 0x7f, 0x93, 0x5c, 0xc0,
	0xda, 0xbc, 0x58, 0x33, 0x9c, 0x53, 0x68, 0xde, 0x81, 0xd1, 0x47, 0x69, 0xa8, 0x95, 0x7b, 0x23,
	0x29, 0xc7, 0x84, 0xfd, 0x5d, 0x84, 0xe6, 0x88, 0xd2, 0x01, 0x5b, 0x44, 0x2c, 0xa4, 0xa1, 0x14,
	0xc8, 0x06, 0x6b, 0xe1, 0x87, 0x66, 0x07, 0xa8, 0xa3, 0x46, 0xc8, 0xcf, 0xe6, 0xe5, 0xab, 0xa3,
	0x5a, 0x08, 0x2e, 0x0b, 0x85, 0x24, 0xa1, 0x34, 0x2f, 0x3e, 0xb5, 0x15, 0xfb, 0x3a, 0x92, 0x5a,
	0x79, 0x0b, 0xab, 0xa3, 0x42, 0x6e, 0x23, 0xa9, 0x35, 0xb6, 0xb0, 0x3a, 0x2a, 0x84, 0x5f, 0x0b,
	0xad, 0x96, 0x85, 0xd5, 0x51, 0x21, 0xe2, 0x5a, 0x74, 0x2b, 0x31, 0x22, 0x62, 0xe4, 0x86, 0x88,
	0x6e, 0x35, 0x46, 0x6e, 0x88, 0x40, 0x2d, 0x28, 0xc9, 0xdb, 0x6e, 0x4d, 0x03, 0x25, 0x79, 0x1b,
	0x57, 0xe2, 0x5d, 0x48, 0x2a, 0x71, 0x84, 0xa0, 0x2c, 0x14, 0x54, 0xd7, 0x90, 0x3e, 0x3b, 0xbf,
	0x15, 0x61, 0x27, 0xb7, 0x7e, 0x46, 0x94, 0x4e, 0xdc, 0x19, 0xf5, 0x96, 0x01, 0x45, 0x97, 0xd0,
	0x99, 0x51, 0x8f, 0x72, 0x32, 0x5a, 0x86, 0xda, 0x49, 0x02, 0x5f, 0xae, 0xf4, 0xe8, 0xad, 0xa3,
	0x5d, 0xa3, 0xd8, 0xf8, 0x7d, 0x06, 0x5e, 0x17, 0x86, 0x0e, 0xa0, 0x32, 0xa5, 0x74, 0x48, 0x24,
	0xb9, 0xf7, 0x5e, 0x46, 0x31, 0x8a, 0x13, 0xb7, 0xf3, 0x67, 0x11, 0x2a, 0x06, 0x44, 0x2f, 0xa1,
	0x1a, 0x32, 0x8f, 0x7a, 0x2a, 0xac, 0x78, 0xe7, 0x96, 0xef, 0x5c, 0x0b, 0x4e, 0x59, 0xe8, 0x73,
	0xa8, 0x87, 0x54, 0xfe, 0xc4, 0xf8, 0xdc, 0xcb, 0x6a, 0xad, 0x0f, 0xca, 0x13, 0x55, 0x9c, 0xa0,
	0xfc, 0xd6, 0x77, 0xe3, 0x62, 0xd6, 0x43, 0x71, 0x39, 0xa2, 0xf3, 0x57, 0x11, 0xea, 0x79, 0xd5,
	0xde, 0xc1, 0x8e, 0x5c, 0xab, 0xa7, 0x79, 0xf7, 0xcf, 0x92, 0x57, 0xb4, 0x96, 0x84, 0xff, 0x25,
	0x18, 0x7d, 0x03, 0x7b, 0xd3, 0xcc, 0xd4, 0x5b, 0xdb, 0x97, 0xab, 0xe4, 0xdf, 0xbb, 0x19, 0xb3,
	0x6d, 0x72, 0x27, 0x30, 0x7e, 0x28, 0xc6, 0xf9, 0x0e, 0xea, 0x6f, 0x98, 0x47, 0x7b, 0x9e, 0xc7,
	0xa9, 0x10, 0x6a, 0xd7, 0xf9, 0x91, 0x31, 0xe2, 0x8d, 0x83, 0x33, 0x00, 0xed, 0xc0, 0x66, 0xc4,
	0xb8, 0x0c, 0x99, 0x2e, 0xb5, 0x81, 0x8d, 0xa5, 0xbe, 0xa9, 0x05, 0x5d, 0xb0, 0x78, 0xd1, 0x60,
	0x7d, 0x76, 0xce, 0xa0, 0x9d, 0x4b, 0xdc, 0x67, 0x6c, 0x8e, 0x4e, 0xa0, 0x1e, 0x66, 0x90, 0x91,
	0x02, 0x99, 0x76, 0x73, 0x64, 0x9c, 0xa7, 0xbd, 0xf8, 0xa3, 0x0c, 0x9d, 0x35, 0x1f, 0x18, 0xb2,
	0xa1, 0x31, 0xe0, 0xab, 0x48, 0xb2, 0x01, 0xa7, 0x44, 0x52, 0xbb, 0x80, 0x10, 0xb4, 0x62, 0x44,
	0xcb, 0x3a, 0xa5, 0xdc, 0x2e, 0x66, 0xac, 0x77, 0x91, 0xa7, 0x58, 0xa5, 0x0c, 0x19, 0xd2, 0x80,
	0x4a, 0x6a, 0x5b, 0x59, 0x5c, 0xcf, 0xf3, 0x06, 0x01, 0xf1, 0x17, 0x76, 0x19, 0x6d, 0x83, 0x9d,
	0x63, 0xc5, 0xe8, 0x86, 0x8e, 0x35, 0xdb, 0x77, 0x40, 0x82, 0xc0, 0xde, 0xd4, 0xb1, 0x09, 0x12,
	0xf7, 0x51, 0xc9, 0x63, 0xa6, 0x6a, 0x15, 0xb5, 0x00, 0xd4, 0xaf, 0x14, 0xc3, 0xa9, 0x25, 0x76,
	0x2f, 0x8a, 0x68, 0xe8, 0xd9, 0x90, 0xd8, 0x86, 0x5f, 0x4f, 0x6c, 0xd3, 0x63, 0x03, 0xed, 0xc1,
	0xe3, 0xb8, 0x9f, 0x33, 0x2a, 0xcd, 0x0f, 0x80, 0x3e, 0x09, 0x48, 0xe8, 0x52, 0xbb, 0xb9, 0xce,
	0x89, 0xa9, 0xcb, 0xb8, 0x27, 0xec, 0x16, 0xda, 0x82, 0x66, 0xea, 0x3c, 0x0f, 0xa7, 0xcc, 0x6e,
	0xa3, 0x47, 0xb0, 0x95, 0x1f, 0xe3, 0x92, 0xb9, 0x24, 0xb0, 0x6d, 0xd4, 0x81, 0x76, 0x02, 0x27,
	0xdc, 0x2d, 0xf4, 0x18, 0x3a, 0x39, 0xb0, 0xbf, 0x92, 0xd4, 0x65, 0x1e, 0xb5, 0x91, 0x62, 0x6b,
	0x60, 0xc2, 0xe2, 0x4f, 0xea, 0x7c, 0x68, 0x77, 0x50, 0x03, 0xaa, 0x1a, 0xbc, 0xa0, 0x2b, 0x7b,
	0x3b, 0x13, 0xf6, 0x2c, 0x91, 0xf0, 0x51, 0x26, 0xec, 0x19, 0x95, 0x13, 0x49, 0xe6, 0x94, 0x0b,
	0x7b, 0x47, 0x25, 0x53, 0xe3, 0x2a, 0x1e, 0x0b, 0xa5, 0x7a, 0x60, 0xf6, 0x63, 0xd4, 0x86, 0xba,
	0x01, 0x75, 0x2f, 0x5d, 0xd4, 0x85, 0xed, 0xdc, 0x8b, 0x39, 0xa3, 0x66, 0x4a, 0xfb, 0x49, 0xff,
	0x13, 0x70, 0x5c, 0xb6, 0x38, 0x8c, 0x77, 0xce, 0x8c, 0x88, 0xd9, 0x0d, 0x27, 0xd1, 0xec, 0x90,
	0x44, 0xbe, 0xf9, 0xbc, 0x7e, 0x24, 0xb7, 0xe4, 0x6d, 0xf1, 0x7a, 0x53, 0x5b, 0xc7, 0xff, 0x04,
	0x00, 0x00, 0xff, 0xff, 0xa5, 0xb4, 0xd0, 0x69, 0x3e, 0x0b, 0x00, 0x00,
}
